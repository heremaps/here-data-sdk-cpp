<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>olp-cpp-sdk: olp::thread::TaskScheduler Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">olp-cpp-sdk
   &#160;<span id="projectnumber">1.16.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceolp.html">olp</a></li><li class="navelem"><b>thread</b></li><li class="navelem"><a class="el" href="classolp_1_1thread_1_1TaskScheduler.html">TaskScheduler</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classolp_1_1thread_1_1TaskScheduler-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">olp::thread::TaskScheduler Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>An abstract interface that is used as a base for the custom thread scheduling strategy.  
 <a href="classolp_1_1thread_1_1TaskScheduler.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="TaskScheduler_8h_source.html">TaskScheduler.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for olp::thread::TaskScheduler:</div>
<div class="dyncontent">
<div class="center"><img src="classolp_1_1thread_1_1TaskScheduler__inherit__graph.png" border="0" usemap="#aolp_1_1thread_1_1TaskScheduler_inherit__map" alt="Inheritance graph"/></div>
<map name="aolp_1_1thread_1_1TaskScheduler_inherit__map" id="aolp_1_1thread_1_1TaskScheduler_inherit__map">
<area shape="rect" title="An abstract interface that is used as a base for the custom thread scheduling strategy." alt="" coords="9,5,188,32"/>
<area shape="rect" href="classolp_1_1thread_1_1ThreadPoolTaskScheduler.html" title="An implementation of the TaskScheduler instance that uses a thread pool." alt="" coords="5,80,192,121"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a54f91863ec0c34f219b21d09d9b09f5a"><td class="memItemLeft" align="right" valign="top"><a id="a54f91863ec0c34f219b21d09d9b09f5a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classolp_1_1thread_1_1TaskScheduler.html#a54f91863ec0c34f219b21d09d9b09f5a">CallFuncType</a> = std::function&lt; void()&gt;</td></tr>
<tr class="memdesc:a54f91863ec0c34f219b21d09d9b09f5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">An alias for the abstract interface input. <br /></td></tr>
<tr class="separator:a54f91863ec0c34f219b21d09d9b09f5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad085c04262d876f3ebc916ec6342d8f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classolp_1_1thread_1_1TaskScheduler.html#ad085c04262d876f3ebc916ec6342d8f6">ScheduleTask</a> (<a class="el" href="classolp_1_1thread_1_1TaskScheduler.html#a54f91863ec0c34f219b21d09d9b09f5a">CallFuncType</a> &amp;&amp;func)</td></tr>
<tr class="memdesc:ad085c04262d876f3ebc916ec6342d8f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedules the asynchronous task.  <a href="classolp_1_1thread_1_1TaskScheduler.html#ad085c04262d876f3ebc916ec6342d8f6">More...</a><br /></td></tr>
<tr class="separator:ad085c04262d876f3ebc916ec6342d8f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa03eccf820b4a88fb8867fa5c3f6a4e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classolp_1_1thread_1_1TaskScheduler.html#aa03eccf820b4a88fb8867fa5c3f6a4e9">ScheduleTask</a> (<a class="el" href="classolp_1_1thread_1_1TaskScheduler.html#a54f91863ec0c34f219b21d09d9b09f5a">CallFuncType</a> &amp;&amp;func, uint32_t priority)</td></tr>
<tr class="memdesc:aa03eccf820b4a88fb8867fa5c3f6a4e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedules the asynchronous task.  <a href="classolp_1_1thread_1_1TaskScheduler.html#aa03eccf820b4a88fb8867fa5c3f6a4e9">More...</a><br /></td></tr>
<tr class="separator:aa03eccf820b4a88fb8867fa5c3f6a4e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eeb0f65973c50c022156ccc690260b2"><td class="memTemplParams" colspan="2">template&lt;class Function , typename std::enable_if&lt;!std::is_convertible&lt; decltype(std::declval&lt; Function &gt;()), CallFuncType &gt;::value , ::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a1eeb0f65973c50c022156ccc690260b2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classolp_1_1client_1_1CancellationContext.html">client::CancellationContext</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classolp_1_1thread_1_1TaskScheduler.html#a1eeb0f65973c50c022156ccc690260b2">ScheduleTask</a> (Function &amp;&amp;func)</td></tr>
<tr class="memdesc:a1eeb0f65973c50c022156ccc690260b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedules the asynchronous cancellable task.  <a href="classolp_1_1thread_1_1TaskScheduler.html#a1eeb0f65973c50c022156ccc690260b2">More...</a><br /></td></tr>
<tr class="separator:a1eeb0f65973c50c022156ccc690260b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a16e3d6bc21a9af0efeb39e527d2bb5f3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classolp_1_1thread_1_1TaskScheduler.html#a16e3d6bc21a9af0efeb39e527d2bb5f3">EnqueueTask</a> (<a class="el" href="classolp_1_1thread_1_1TaskScheduler.html#a54f91863ec0c34f219b21d09d9b09f5a">CallFuncType</a> &amp;&amp;)=0</td></tr>
<tr class="memdesc:a16e3d6bc21a9af0efeb39e527d2bb5f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The abstract enqueue task interface that is implemented by the subclass.  <a href="classolp_1_1thread_1_1TaskScheduler.html#a16e3d6bc21a9af0efeb39e527d2bb5f3">More...</a><br /></td></tr>
<tr class="separator:a16e3d6bc21a9af0efeb39e527d2bb5f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a527ad198981efe6690e6222180cc1e24"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classolp_1_1thread_1_1TaskScheduler.html#a527ad198981efe6690e6222180cc1e24">EnqueueTask</a> (<a class="el" href="classolp_1_1thread_1_1TaskScheduler.html#a54f91863ec0c34f219b21d09d9b09f5a">CallFuncType</a> &amp;&amp;func, uint32_t priority)</td></tr>
<tr class="memdesc:a527ad198981efe6690e6222180cc1e24"><td class="mdescLeft">&#160;</td><td class="mdescRight">The enqueue task with priority interface that is implemented by the subclass.  <a href="classolp_1_1thread_1_1TaskScheduler.html#a527ad198981efe6690e6222180cc1e24">More...</a><br /></td></tr>
<tr class="separator:a527ad198981efe6690e6222180cc1e24"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>An abstract interface that is used as a base for the custom thread scheduling strategy. </p>
<p>Subclasses should inherit from this class and implement virtual <code>EnqueueTask</code> that takes any callable target (lambda expression, bind expression, or any other function object) as input and adds it to the execution pipeline. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a16e3d6bc21a9af0efeb39e527d2bb5f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16e3d6bc21a9af0efeb39e527d2bb5f3">&#9670;&nbsp;</a></span>EnqueueTask() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void olp::thread::TaskScheduler::EnqueueTask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classolp_1_1thread_1_1TaskScheduler.html#a54f91863ec0c34f219b21d09d9b09f5a">CallFuncType</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The abstract enqueue task interface that is implemented by the subclass. </p>
<p>Implement this method in the subclass that takes <code><a class="el" href="classolp_1_1thread_1_1TaskScheduler.html" title="An abstract interface that is used as a base for the custom thread scheduling strategy.">TaskScheduler</a></code> as a base and provides a custom algorithm for scheduling tasks enqueued by the SDK.</p>
<dl class="section note"><dt>Note</dt><dd>Tasks added trough this method should be scheduled with Priority::NORMAL priority. </dd></dl>

<p>Implemented in <a class="el" href="classolp_1_1thread_1_1ThreadPoolTaskScheduler.html#a6b39865fcd7402003c4ae0e5846b8db5">olp::thread::ThreadPoolTaskScheduler</a>.</p>

</div>
</div>
<a id="a527ad198981efe6690e6222180cc1e24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a527ad198981efe6690e6222180cc1e24">&#9670;&nbsp;</a></span>EnqueueTask() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void olp::thread::TaskScheduler::EnqueueTask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classolp_1_1thread_1_1TaskScheduler.html#a54f91863ec0c34f219b21d09d9b09f5a">CallFuncType</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The enqueue task with priority interface that is implemented by the subclass. </p>
<p>Implement this method in the subclass that takes <code><a class="el" href="classolp_1_1thread_1_1TaskScheduler.html" title="An abstract interface that is used as a base for the custom thread scheduling strategy.">TaskScheduler</a></code> as a base and provides a custom algorithm for scheduling tasks enqueued by the SDK. The method priorities tasks, so tasks with higher priority executed earlier. Tasks within the same priority group should keep the order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>The rvalue reference of the task that should be enqueued. Move this task into your queue. No internal references are kept. Once this method is called, you own the task. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">priority</td><td>The priority of the task. Tasks with higher priority executes earlier. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classolp_1_1thread_1_1ThreadPoolTaskScheduler.html#a680028d184c3e2d4e31c0a2555cb3797">olp::thread::ThreadPoolTaskScheduler</a>.</p>

</div>
</div>
<a id="ad085c04262d876f3ebc916ec6342d8f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad085c04262d876f3ebc916ec6342d8f6">&#9670;&nbsp;</a></span>ScheduleTask() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void olp::thread::TaskScheduler::ScheduleTask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classolp_1_1thread_1_1TaskScheduler.html#a54f91863ec0c34f219b21d09d9b09f5a">CallFuncType</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Schedules the asynchronous task. </p>
<dl class="section note"><dt>Note</dt><dd>Tasks added with this method has Priority::NORMAL priority.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>The callable target that should be added to the scheduling pipeline. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa03eccf820b4a88fb8867fa5c3f6a4e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa03eccf820b4a88fb8867fa5c3f6a4e9">&#9670;&nbsp;</a></span>ScheduleTask() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void olp::thread::TaskScheduler::ScheduleTask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classolp_1_1thread_1_1TaskScheduler.html#a54f91863ec0c34f219b21d09d9b09f5a">CallFuncType</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Schedules the asynchronous task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>The callable target that should be added to the scheduling pipeline. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">priority</td><td>The priority of the task. Tasks with higher priority executes earlier. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1eeb0f65973c50c022156ccc690260b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eeb0f65973c50c022156ccc690260b2">&#9670;&nbsp;</a></span>ScheduleTask() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Function , typename std::enable_if&lt;!std::is_convertible&lt; decltype(std::declval&lt; Function &gt;()), CallFuncType &gt;::value , ::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classolp_1_1client_1_1CancellationContext.html">client::CancellationContext</a> olp::thread::TaskScheduler::ScheduleTask </td>
          <td>(</td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Schedules the asynchronous cancellable task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>The callable target that should be added to the scheduling pipeline. As <code>CancellationContext</code> is created internally, it is passed as input, so the callable function should have the following signature:</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> func(CancellationContext&amp; context);</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>Returns the <code>CancellationContext</code> copy to the caller. The copy can be used to cancel the enqueued tasks. Tasks can only be canceled before or during execution if the task itself is designed to support this. Tasks are also able to cancel the operation themselves as they get a non-const reference to the <code>CancellationContext</code> class. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>olp-cpp-sdk-core/include/olp/core/thread/<a class="el" href="TaskScheduler_8h_source.html">TaskScheduler.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
